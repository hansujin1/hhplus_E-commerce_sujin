[비관적 락 vs 낙관적 락]
비관적 락 : 충돌이 자주 발생할 것으로 예상되는 상황에서 사용 -> 미리 Lock을 걸어 다른 트랜잭션이 접근하지 못하도록 함
          대기 시간으로 인한 지연이 일어날 가능성이 높음

-- 비관적 락 예시 sql
    BEGIN;
    SELECT * FROM product WHERE product_id = 1 FOR UPDATE;
    UPDATE product SET stock = stock - 5 WHERE product_id = 1;
    COMMIT;


낙관적 락 : 충돌이 자주 일어나지 않는 상황에서 사용 -> Lock을 걸지 않고 버전 컬럼을 두어 데이터 변경 여부를 확인 후 진행, 실패 시 재시도
          충돌 시 재시도를 하기 때문에 오버헤드 발생 가능성 있음
-- 낙관적 락 예시
@Entity
public class User {
    @Id
    private Long id;

    private int point;

    @Version  // 낙관적 락을 위한 버전 관리
    private Long version;
}
--> version이 기대한 값과 다르면 commit하지 않고 재시도

※현재 코드에서 동시성 문제가 발생할 수 있는 부분
1. 선착순 쿠폰 발급 - 한정 수량 쿠폰인 경우, 동시에 많은 사람들이 요청했을 시 정확한 수량만큼만 발급되어야 함
2. 재고관리 - 사용자가 구매버튼을 클릭했을 때부터의 재고 확인, 차감 부분을 관리해야 함
3. 포인트 차감 - 사용자가 각기 다른 곳에서 포인트를 동시에 사용했을 때의 차감 처리


1. 선착순 쿠폰 발급 동시성 제어 - 비관적 락

[문제 발생]
쿠폰이 10개가 남아 있는 상태에서 30명이 동시에 쿠폰 발급을 시도할 때,
쿠폰 수량 확인 및 차감이 제대로 이루어지지 않아 남아있는 쿠폰 수량보다 더 많이 발급되는 문제 발생

[문제 발생 시나리오]
1. 쿠폰 잔여 수량: 1개
2. A, B 사용자가 동시에 발급 요청
3. A 확인: 1개 남음 → 발급 가능
4. B 확인: 1개 남음 → 발급 가능 (A의 차감이 아직 반영 안 됨)
5. A 발급 완료: 0개 남음
6. B 발급 완료: -1개 남음... 실제로는 0개이고, 발급이 되면 안되지만 발급될 수 있음
7. 결과: 정확한 수량 제어 실패

[분석]
선착순 쿠폰 발급은 이벤트성 기능으로 경쟁과 충돌이 자주 발생할 수밖에 없는 기능으로 낙관적 락을 쓰게 되면 재시도하는 횟수가 과도하게 발생하여, DB에 무리를 줄 수 있음
처음부터 Lock을 걸어서 들어온 순서대로 발급하여 정확히 수량제어가 필요하여, 비관적 락을 이용하는 것이 효율적으로 보임

[해결]
--기존 구현 방식
CouponService에서 ReentrantLock을 이용해서 Lock을 잡음

-- 수정 후
[CouponService - issueCoupon method]
 @Transactional
    public UserCoupon issueCoupon(Long userId, Long couponId) {

            Coupon coupon = couponRepository.findByCouponIdWithLock(couponId)
                    .orElseThrow(() -> new IllegalStateException("쿠폰을 찾을 수 없습니다."));
            .
            .
            .
            return userCouponRepository.save(userCoupon);
    }

-- Transactional 어노테이션 추가 후 Lock을 잡는 쿼리로 수정

[CouponJpaRepository.java]
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT c FROM Coupon c WHERE C.couponId = :couponId")
    Optional<Coupon> findByCouponIdWithLock(@Param("couponId") Long couponId);


2. 재고관리 및 구매 - 비관적 락

[문제 발생]
재고가 10개 남은 상태에서 A와 B가 각각 5개, 6개를 동시에 주문할 때, 동시성 제어를 하지 않으면 재고 확인 및 차감이 제대로 이루어지지 않아
총 11개가 판매되어 재고가 -1개(음수)가 되는 문제가 발생할 수 있음


[분석]
재고는 e-commerce에 있어서 핵심 부분 중 하나로 모든 주문에 재고 확인,차감은 발생하는 부분으로 충돌 빈고가 높고, 음수 재고 발생 시 심각한 문제로 이어질 수 있음
지연이 되더라도 정확한 데이터 정합성이 우선이기 때문에 비관적 락을 이용하여 동시성을 제어하는 것이 적합하다고 판단

[해결]
-- 기존에 Lock을 잡는 부분이 없었음
   validate하면서 select한 데이터로 재고 차감하는 형식으로 함

-- 수정 후
[ProductService.java - minusStock]
@Transactional
    public void minusStock( @NotEmpty List<OrderCreateRequest.Item> items) {
    .
    .
    .
    Product product = productRepository.findByProductIdWithLock(productId)
                        .orElseThrow(() -> new IllegalStateException("상품을 찾을 수 없습니다: " + productId));

    }

[ProductJpaRepository.java]
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p where p.productId = :productId")
    Optional<Product> findByProductIdWithLock(@Param("productId") Long productId);


3. 포인트 차감 - 낙관적 락

[문제 발생]
한 사용자가 여러 기기(또는 탭)에 동시에 로그인되어 있어 동시에 포인트로 결제를 시도했을 때, 포인트 확인 및 차감이 제대로 일어나지 않을 수 있음
예: 사용자가 10,000 포인트를 보유한 상태에서 A에서 8,000 포인트, B에서 8,000 포인트를 동시 사용 시도
    → 둘 다 잔액 확인 시점에 10,000 포인트 확인 → 모두 결제 진행 → 총 16,000 포인트 차감되어 -6,000 포인트 발생

[문제 발생 시나리오]
 1. 사용자 잔액: 10,000 포인트
 2. 기기 A에서 8,000 포인트 결제 시도 → 잔액 확인: 10,000 (가능)
 3. 기기 B에서 8,000 포인트 결제 시도 → 잔액 확인: 10,000 (가능)
 4. A 결제 완료: 10,000 - 8,000 = 2,000 포인트
 5. B 결제 완료: 10,000 - 8,000 = 2,000 포인트 (잘못된 계산)
 6. 실제 잔액: -6,000 포인트 (음수 발생!)

[분석]
포인트 중복 사용 같은 경우 선착순 쿠폰이나 재고관리와 달리 발생할 확률이 높지 않아
매번 Lock을 잡아 처리하는 방식보다는 버전을 확인하여 충돌 시 재시도하는 낙관적 락 쪽이 더 적합하다고 생각함

[해결]
